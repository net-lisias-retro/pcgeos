/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (c) Geoworks 1994 -- All Rights Reserved

PROJECT:	Socket 
MODULE:		TCP/IP Driver
FILE:		tcpip.goc

AUTHOR:		Jennifer Wu, Jul  6, 1994

ROUTINES:
	Name			Description
	----			-----------

	TcpipConfigureProtocols If protocol level configuration is allowed,
	    	    	    	this routine reads settings from INI file
				to alter the behaviour of the protocol.
	    	    	    	

REVISION HISTORY:
	Name		Date		Description
	----		----		-----------
	jwu		7/ 6/94   	Initial version.

DESCRIPTION:
	Definitions and methods for TcpipProcessClass.

	$Id: tcpip.goc,v 1.1 97/04/18 11:57:04 newdeal Exp $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@include <stdapp.goh>

#include <geos.h>
#include <thread.h>
#include <sem.h>
#include <timer.h>
#include <initfile.h>
#include <ec.h>
#include <Internal/socketDr.h>
#include <tcpip.h>
#include <tcpipLog.h>
@include <accpnt.goh>
#include <ansi/string.h>

/*---------------------------------------------------------------------------*
 *		     Class & Message Definitions
 *  
 *  The driver has its own thread for processing events.  Routines for the
 *  driver's interface will usually do some small bookkeeping and then queue
 *  the event for the driver to process.  The TcpipProcessClass is created
 *  to run the driver's thread.
 *---------------------------------------------------------------------------*/

@class	TcpipProcessClass, ProcessClass;

/*
 * Start the process required to open a connection.
 */
@message void MSG_TCPIP_OPEN_CONNECTION(word connection = cx);

/*
 * Start the process to close a connection.
 */
@message void MSG_TCPIP_CLOSE_CONNECTION(word connection = cx);

/*
 * Start the process to reset a connection.
 */
@message void MSG_TCPIP_RESET_CONNECTION(word connection = cx, word error = dx);

/* 
 * Start the process to open a connection requested by the peer.
 */
@message void MSG_TCPIP_ACCEPT_CONNECTION(word connection = cx);

/*
 * Process outgoing data for a connection.
 */
@message word MSG_TCPIP_SEND_DATA(word connection = cx, word mode = dx) = ax;

/*
 * Send datagram.
 */
@message word MSG_TCPIP_SEND_DATAGRAM(word link = cx, optr buffer = dx:bp) = ax;

/* 
 * Process incoming data from the network.
 */
@message void MSG_TCPIP_RECEIVE_DATA();

/*
 * Process a timeout.
 */
@message void MSG_TCPIP_TIMEOUT_OCCURRED ();

/*
 * Delete a link.
 */
@message void MSG_TCPIP_DELETE_LINK (word link = cx);

/*
 * Destroy all Tcp connections.
 */
@message void MSG_TCPIP_DESTROY_CONNECTIONS ();

/*
 * Send a raw ip packet.
 */
@message word MSG_TCPIP_SEND_RAW_IP(word link = cx, optr buffer = dx:bp) = ax;

/*
 * DHCP lease renewal messages
 */
@message void MSG_TCPIP_DHCP_RENEW_TIMER();
@message void MSG_TCPIP_DHCP_RENEW_NOW();
@message void MSG_TCPIP_START_RECEIVE(word link = cx);

@endc

@classdecl	TcpipProcessClass, neverSaved;
@method TcpipProcessClass, MSG_META_DUMMY {
}

#ifdef __HIGHC__
#pragma Code("TCPCODE");
#endif
#ifdef __BORLANDC__
#pragma codeseg TCPCODE
#endif

/*--------------------------------------------------------------------------*
 *			       Methods
 *--------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------
		      MSG_TCPIP_OPEN_CONNECTION
---------------------------------------------------------------------------
SYNOPSIS:	Start the process required to open a connection.
 
PASS:		connection	= handle of connection to open
 
RETURN:		nothing

SIDE EFFECTS:	Initiates TCP protocol for establishing a connection.
 
STRATEGY:
		initialize tcp template header
		set tcp state to SYN_SENT
		initialize keep alive timer
		initialize initial send sequence # and relatives
		call the TCP output function 
 
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 6/94   	Initial Revision
 
---------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_OPEN_CONNECTION
{
}	/* End of MSG_TCPIP_OPEN_CONNECTION.	*/


/*-------------------------------------------------------------------------
			     MSG_TCPIP_CLOSE_CONNECTION
---------------------------------------------------------------------------
SYNOPSIS:	Start the process to close a connection.
   
PASS:		connection = handle of connection to close

RETURN:		nothing
   
SIDE EFFECTS:	Initiates TCP protocol for closing a connection.
 
STRATEGY:
		if we never got a SYN, just wake up waiter so 
			close can continue
		if we got a SYN from the peer but haven't sent FIN,
			go to FIN_WAIT_1
		if already got a FIN, go to LAST_ACK state
		
		In all other cases, we have already sent FIN to peer
		and just have to wait for peer to send FIN or not 
		respond to keep-alives.
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 6/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_CLOSE_CONNECTION
{

	TcpipReceiveStop(connection);


}	/* End of MSG_TCPIP_CLOSE_CONNECTION.	*/



/*-------------------------------------------------------------------------
			     MSG_TCPIP_RESET_CONNECTION
---------------------------------------------------------------------------
SYNOPSIS:	Start the process to reset a connection.
   
PASS:		connection = handle of connection to reset.
                error      = SocketDrError
		    	      (SDE_CONNECTION_RESET, possibly or-ed with
			       SpecSocketDrError from link driver)

RETURN:		nothing
   
SIDE EFFECTS:	Initiates TCP protocol for resetting a connection.
 
STRATEGY:
		if have received SYN, set state to CLOSED and 
			call tcp output routine
		wake up waiter now that reset has been sent
		connection will be destroyed when waiter awakes
		
		calling	TcpDrop should take care of the above...

REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 6/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_RESET_CONNECTION
{
	
}	/* End of MSG_TCPIP_RESET_CONNECTION.	*/


/*-------------------------------------------------------------------------
			     MSG_TCPIP_ACCEPT_CONNECTION
---------------------------------------------------------------------------
SYNOPSIS:	Start the process to open a connection requested by the 
		peer.
   
PASS:		connection	= connection to open

RETURN:		nothing
   
SIDE EFFECTS:	Initiates TCP protocol for responding to a connection 
		request.
 
STRATEGY:
		Initialize tcp template header
		set tcp state to SYN_RECEIVED
		initialize keep alive timer
		initialize initial send sequence # and relatives		
		call the TCP output function
	 

REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 6/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_ACCEPT_CONNECTION
{

}	/* End of MSG_TCPIP_ACCEPT_CONNECTION.	*/


/*-------------------------------------------------------------------------
			     MSG_TCPIP_SEND_DATA
---------------------------------------------------------------------------
SYNOPSIS:	Process outgoing data for a connection.
   
PASS:		connection	= connection to with data to be sent
		mode		= SocketSendMode

RETURN:		word            = SocketDrError
   
STRATEGY:
		call the tcp output routine
  
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 6/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_SEND_DATA
{
	return SDE_UNSUPPORTED_FUNCTION;

}	/* End of MSG_TCPIP_SEND_DATA.	*/


/*-------------------------------------------------------------------------
			     MSG_TCPIP_SEND_DATAGRAM
---------------------------------------------------------------------------
SYNOPSIS:	Send a datagram.
   
PASS:		link	= link domain handle
		buffer	= optr of data buffer

RETURN:		word 	= SocketDrError
   
STRATEGY:
		get the local address for the link
  		call the UDP output routine
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	10/11/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_SEND_DATAGRAM
{
	return SDE_UNSUPPORTED_FUNCTION;

}	/* End of MSG_TCPIP_SEND_DATAGRAM.	*/




/*-------------------------------------------------------------------------
			     MSG_TCPIP_RECEIVE_DATA
---------------------------------------------------------------------------
SYNOPSIS:	Process incoming data from the network.
   
PASS:		nothing

RETURN:		nothing
   
SIDE EFFECTS:	data buffer will be freed after data has been passed
		to the socket library
 
STRATEGY:   	Increment input counter to allow another packet to
                  be processed
		call IpInput and let that handle it

REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 6/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_RECEIVE_DATA
{
    	optr buffer;

    	buffer = TcpipDequeuePacket();

	//if (buffer)
	//    IpInput(buffer);

}	/* End of MSG_TCPIP_RECEIVE_DATA.	*/

#ifdef __HIGHC__
#pragma Code("TSOCKETCODE"); 
#endif
#ifdef __BORLANDC__
#pragma codeseg TSOCKETCODE
#endif


/*-------------------------------------------------------------------------
			     MSG_TCPIP_TIMEOUT_OCCURRED
---------------------------------------------------------------------------
SYNOPSIS:	Process a timeout of the TCP/IP timer by decrementing
		counters.
   
PASS:		nothing

RETURN:		nothing
   
SIDE EFFECTS:	May cause other actions to occur if a counter reaches 
		zero, indicating a timeout.  Connections may be destroyed,
		data may be sent...
 
STRATEGY:
		Call SocketTimeoutHanlder which enumerates the chunk 
		array of sockets:
			if it is rejected, decrement the destoy counter
			and destroy the connection if it reaches zero
			else if it is OPEN, DISCONNECTING or CONNECTING, 
			call Tcp timeout handler
		Call Ip timeout handler so it can do timeout processing
			on the reassembly queue

REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	7/ 7/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_TIMEOUT_OCCURRED
{
	TcpipReceiveStart(0);
	//TSocketTimeoutHandler();
	//IpTimeoutHandler();
}	/* End of MSG_TCPIP_TIMEOUT_OCCURRED.	*/


#ifdef __HIGHC__
#pragma Code("TCPCODE"); 
#endif
#ifdef __BORLANDC__
#pragma codeseg TCPCODE
#endif


/*-------------------------------------------------------------------------
			     MSG_TCPIP_DELETE_LINK
---------------------------------------------------------------------------
SYNOPSIS:   Delete a closed link.  
   
PASS:	    link    = domain handle of link to delete

RETURN:	    nothing
   
SIDE EFFECTS:
 	    TCP's thread will be sent a MSG_META_DETACH if this is the
	    last remaining link.

REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	1/24/95   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_DELETE_LINK
{
    	LinkTableDeleteEntry(link);

}	/* End of MSG_TCPIP_DELETE_LINK.	*/




/*-------------------------------------------------------------------------
			     MSG_TCPIP_DESTROY_CONNECTIONS
---------------------------------------------------------------------------

SYNOPSIS:   Destroy all Tcp connections.  
   
PASS:	    nothing

RETURN:	    nothing
   
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	10/23/95   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_DESTROY_CONNECTIONS
{
	//TODO
    //TSocketDestroyAllConnections();

}	/* End of MSG_TCPIP_DESTROY_CONNECTIONS.	*/




/*-------------------------------------------------------------------------
			     MSG_TCPIP_SEND_RAW_IP
---------------------------------------------------------------------------
SYNOPSIS:	Send a raw Ip packet.
   
PASS:		link	= link domain handle 
		buffer	= optr of data buffer

RETURN:		word = SocketDrError
   
STRATEGY:
  
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	10/14/94   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_TCPIP_SEND_RAW_IP
{
	return SDE_UNSUPPORTED_FUNCTION;

}	/* End of MSG_TCPIP_SEND_RAW_IP.	*/




/*-------------------------------------------------------------------------
			     MSG_META_DETACH
---------------------------------------------------------------------------
SYNOPSIS:   Intercepted to prevent TCP from exiting before clients do.
   
PASS:	    callerID
            caller

RETURN:	    nothing
   
STRATEGY:   If it is safe to exit TCP, call superclass.  
            Else, do nothing.
  
REVISION HISTORY:
 	Name	Date		Description
 	----	----		-----------
 	jwu	1/23/95   	Initial Revision
 
-------------------------------------------------------------------------*/
@method TcpipProcessClass, MSG_META_DETACH
{
    	if (TcpipDetachAllowed()) 
	    @callsuper();

}	/* End of MSG_META_DETACH.	*/




/*--------------------------------------------------------------------------
 *	    Code for configuring TCPIP options
 -------------------------------------------------------------------------*/

@ifdef PROTO_CONFIG_ALLOWED

/*
 * INI key strings.
 */
@start Strings, data;
@chunk char tcpipString[] = {'t','c','p','i','p',0};
    @localize not;
@chunk char maxTTLString[] = {'m','a','x','T','T','L',0};
    @localize not;
@chunk char mssString[] = {'d','e','f','a','u','l','t','M','S','S',0};
    @localize not;
@chunk char maxWinString[] = {'m','a','x','W','i','n',0};
    @localize not;
@chunk char maxRexmtString[] = {'m','a','x','R','e','x','m','t',0};
    @localize not;
@chunk char minRexmtString[] = {'m','i','n','R','e','x','m','t',0};
    @localize not;
@chunk char maxIdleString[] = {'m','a','x','I','d','l','e',0};
    @localize not;
@chunk char maxProbesString[] = {'m','a','x','P','r','o','b','e','s',0};
    @localize not;
@chunk char compatString[] = {'c','o','m','p','a','t','B','S','D','4','2',0};
    @localize not;
@chunk char rttString[] = {'r','t','t',0};
    @localize not;
@chunk char rttShiftString[] = {'r','t','t','S','h','i','f','t',0};
    @localize not;
@chunk char rttvarShiftString[] = {'r','t','t','v','a','r','S','h','i','f','t',0};
    @localize not;
@end Strings;



@endif


/***********************************************************************
 *		TcpipDhcpConvertTime
 ***********************************************************************
 *
 * SYNOPSIS:	Takes a TimerDateAndTime struct, and fills in another
 * 		TimerDateAndTime struct with a time a specified number
 *		of seconds later.
 *
 * CALLED BY:	TcpipDhcpParseAndSendNotification
 * RETURN:	
 * SIDE EFFECTS:
 *	
 * STRATEGY:
 *	
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *      ed	7/07/00   	Initial Revision
 *
 ***********************************************************************/
void CALLCONV
TcpipDhcpConvertTime (TimerDateAndTime *start, TimerDateAndTime *end,
		      dword secs)
{
    word days;
    memcpy(end, start, sizeof(TimerDateAndTime));

    while (secs > ((dword)365*24*60*60)) {
	secs -= ((dword)365*24*60*60);
	days = LocalCalcDaysInMonth((end->TDAT_month > 2) ?
				    (++end->TDAT_year) :
				    (end->TDAT_year++), 2);
	if (days == 28) continue;

	if (end->TDAT_month == 2 && end->TDAT_day == 29) {
	    end->TDAT_day = 1;
	    end->TDAT_month = 3;
	}
	else {
	    if (secs > ((dword)24*60*60)) {
		secs -= ((dword)24*60*60);
	    }
	    else {
		if (--end->TDAT_day == 0) {
		    if (--end->TDAT_month == 0) {
			end->TDAT_year--;
			end->TDAT_month = 12;
			end->TDAT_day = 31;
		    }
		    else {
			end->TDAT_day = LocalCalcDaysInMonth(end->TDAT_year,
							     end->TDAT_month);
		    }
		}
	    }
	}
    } /* while > 1 year remaining */


    /* Move the date up to the 1st of the next month, if we can */

    if (end->TDAT_day != 1) {
	days = LocalCalcDaysInMonth(end->TDAT_year, end->TDAT_month) -
	    end->TDAT_day + 1;
	if (secs > (days * (dword)24*60*60)) {
	    secs -= (days * (dword)24*60*60);
	    end->TDAT_day = 1;
	    if (end->TDAT_month != 12) {
		end->TDAT_month++;
	    }
	    else {
		end->TDAT_month = 1;
		end->TDAT_year++;
	    }
	}
	else {
	    days = secs / ((dword)24*60*60);
	    end->TDAT_day += days;
	    secs -= (days * (dword)24*60*60);
	    goto checkHours;
	}
    }

    /* Check the months */
    while (secs > ((days = LocalCalcDaysInMonth(end->TDAT_year,
						end->TDAT_month))*24*60*60)) {
	secs -= (days * (dword)24*60*60);
	if (end->TDAT_month != 12) {
	    end->TDAT_month++;
	}
	else {
	    end->TDAT_month = 1;
	}
    }

    /* Check the days */
    days = secs / ((dword)24*60*60);
    end->TDAT_day += days;
    secs -= (days * (dword)24*60*60);

    /* Note: From here on, I'm still using the variable days, even tho it's
       not really storing days anymore as it's pointless to make more
       variables. */
checkHours:
    /* Check the hours */
    if (secs > ((dword)60*60)) {
	days = secs / ((dword)60*60);
	end->TDAT_hours += days;
	secs -= (days * (dword)60*60);
    }

    /* Check the minutes */
    if (secs > 60) {
	days = secs / ((dword)60);
	end->TDAT_minutes += days;
	secs -= (days * (dword)60);
    }

    /* Account for any remaining seconds */
    end->TDAT_seconds += secs;

    /* Now check for overflows */
    if (end->TDAT_seconds > 59) {
	end->TDAT_minutes++;
	end->TDAT_seconds -= 60;
    }

    if (end->TDAT_minutes > 59) {
	end->TDAT_minutes -= 60;
	end->TDAT_hours++;
    }

    if (end->TDAT_hours > 23) {
	end->TDAT_hours -= 24;
	if (end->TDAT_day == LocalCalcDaysInMonth(end->TDAT_year,
						  end->TDAT_month)) {
	    if (end->TDAT_month < 12) {
		end->TDAT_month++;
	    }
	    else {
		end->TDAT_month = 1;
		end->TDAT_year++;
	    }
	    end->TDAT_day = 1;
	}
	else {
	    end->TDAT_day++;
	}
    }

    end->TDAT_dayOfWeek = LocalCalcDayOfWeek(end->TDAT_year, end->TDAT_month,
					     end->TDAT_day);
}	/* End of TcpipDhcpConvertTime.	*/

@method TcpipProcessClass, MSG_TCPIP_DHCP_RENEW_TIMER,
    MSG_TCPIP_DHCP_RENEW_NOW
{
    if (message == MSG_TCPIP_DHCP_RENEW_TIMER) {
	TcpipDhcpTimerHandler();
    }
    else {
	TcpipDhcpStartRenew();
    }
}

@method TcpipProcessClass, MSG_TCPIP_START_RECEIVE
{
	TcpipReceiveStart(link);
}
